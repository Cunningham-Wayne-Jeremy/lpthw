-----------------------------------------------------------------------------------------------------
The print command has ()s after it like so print()
It can print letters numbers and variables
# is the comment character
-----------------------------------------------------------------------------------------------------
For some odd reason the print("string", 1 + 2) fails I do not understand why
Its because you were using python 2.0 derp to avoid this use python3.6 ex2.py
-----------------------------------------------------------------------------------------------------
PEMDAS isnt as simple as the acronym suggests its actually better represented
as PE (M&D) (A&S) so Parenthesis, exponents THEN Multiplication and division
happen at the same time andaddition and subtraction happen at the same time
after that.
-----------------------------------------------------------------------------------------------------
Variables are easily declared in python just variable name = something
-----------------------------------------------------------------------------------------------------
f is a formatting character and is used to reference variables inside strings
for example print(f"My age is {my_age}.") pretty simple but keep in mind that in
a print statement the f goes INSIDE the Parenthesis but outside the quotations
-----------------------------------------------------------------------------------------------------
You can use f in variables like so: var1 = f"Its the same {var}" REMEMBER that
-----------------------------------------------------------------------------------------------------
You can also use stat a string with a {} in a variable and then you can change
it later. For example x = "No f yet but we will leave some {} here"
print(x.format(brackets))
You only need one variable and the print function. I assume there are other ways
to do this without the print function though. Its very interesting REMEMBER THIS
-----------------------------------------------------------------------------------------------------
You can use the + to concatenate strings and variables as well
-----------------------------------------------------------------------------------------------------
# the .format('snow')) can be used to change the values within the curly brackets
#but if there are multiple brackets how do you differentiate them from each other?? It goes first
come first serve like so:
print(x.format(first, second, third))
#The reason this is important is that it can be used in loops or other situations
 where a string is already defined?
-----------------------------------------------------------------------------------------------------
f is the same as .format(). For example
print("Its fleece was white as {}".format('snow'))
The above code is the same as:
print(f"Its fleece was white as {snow}")
-----------------------------------------------------------------------------------------------------
print("a" * 10) This will print the character a 10 times interesting that you can
do math on strings.
-----------------------------------------------------------------------------------------------------
,end="" allows you to print on the same line. If you use: + " " it will perform
a line break which may not be the desired result.
So Remember , end=" " means no line break where + will add a line break
-----------------------------------------------------------------------------------------------------
placeholdervar = {}{}{}{}{}{}{}{}

print(placeholdervar.format('1','2','3','4','5','6','7','8'))

-----------------------------------------------------------------------------------------------------
\ is the escape character good for escaping out of quotes and getting around
special characters
-----------------------------------------------------------------------------------------------------
"""This is a multi line string
As long as it starts and ends with
 \"\"\" characters. It will continue
forever"""
----------------------------------------------------------------------------------------------------
ERROR: I used a /n instead of a \n DONT DO THAT!
----------------------------------------------------------------------------------------------------
There are a good amount of escape character combinatations
WHY use these?
\t tabs
\n as mentioned goes to a new line
\r does a carriage return which is like a new line except in some situations
its a little different
\ combined with a special char will exclude a special characters like ' or "
There are also \ combinations that allow different formatting
----------------------------------------------------------------------------------------------------

 end=' ' What is it again?
            First: its used only with the print command
            Second: The print command will always go to a new line
            But if you dont want the output to go on a NEW line but stay on the SAME line
            you should use end = ' '
            This tells Python to end the string with a space instead
            Thats really all there is to it.
REMEMBER^
----------------------------------------------------------------------------------------------------
REMEMBER: User input is easy just assign a variable like so:
usrinput = input()
To make this easier lets put the prompt as a question to save us a print() cmd
whatisyourage = input("Enter your age.")
----------------------------------------------------------------------------------------------------
You can put the prompt inside the input like so: var = input("Enter your name:")
----------------------------------------------------------------------------------------------------
pydoc! its like the man pages for commands,keywords and anything in python!
REMEMBER IT
----------------------------------------------------------------------------------------------------
pydoc file will open a file and write or append to it!
----------------------------------------------------------------------------------------------------
pydoc sys This will allow you to change path names, stdin and stuff like that?
IDK what I DO know is that sys will allow you to import more code that is built
in to python.
----------------------------------------------------------------------------------------------------
pydoc os

----------------------------------------------------------------------------------------------------
Argv - you import this MODULE with sys like so from sys argv you can then assign it
arguments that you will have to provide it to run the python script. So when
typing in the command python3.6 you need to specify what the script for one then
the following variables that will be sent to argv. When the script is ran it
unpacks argv and will send your code those variables on request.
----------------------------------------------------------------------------------------------------
You can import modules to Python this is to reduce the overhead if it was already
usable by python and just not used. Modules are often called libraries.
----------------------------------------------------------------------------------------------------
from sys import argv
ageinput = input("What is your age? ")
heightinput = input("What is your height? ")
weightinput = input("What is your wieght? ")

script, averageage, averageheight, averageweight = argv
#In the future we can add some conditional statements to compare the average to
the user input and print other things below!!!
print(f"The average age is {averageage} but your age is {ageinput}.")
print(f"The average height is {averageheight} but your height is {heightinput}.")
print(f"The average weight is {averageweight} but your weight is {weightinput}.")

The above code that I wrote is a good example of using both the argv and inputs
together to provide a cool mix of code. REMEMBER that the variables supplied to
argv are just normal variables and can be referenced with {}. You can even make
conditional statements after to say your under the average age your young or
over the average your old!
----------------------------------------------------------------------------------------------------
IDEAS FOR YOUR OWN CODE! make a loading bar! [#################.................]
Do this in your journal application that you will write
----------------------------------------------------------------------------------------------------
This goes without saying but you can use f inside a 3 qoute string like so: f"""
 Some words {text} """ obviously
----------------------------------------------------------------------------------------------------
f is not just for print you can use it with input too!!!
prompt=">"
firstnumber = input(f"Enter the first number{prompt}")
----------------------------------------------------------------------------------------------------
verysimplecalc.py
eval will calculate the value of strings that are actually numbers and operators
like so: eval(f'{firstnumber} {operator} {secondnumber}')
eval is very useful as you dont have to convert the strings to integers before making calculations
When using argv for calculations with eval remember that input considers the *(multiplication)
a special character so you will need to use \* to exclude it.
----------------------------------------------------------------------------------------------------
ex15.py
Open and read can be used to open the contents of a file in python and then read
can be used to see the contents of said file. READ IS AN ATTRIBUTE
----------------------------------------------------------------------------------------------------
OPEN: CREATES A FILE OBJECT.
so open will open a file but it will not return anything on its own.  Ex:
var = open(filename)
Open can be ran with modes of operation which are r, w and a
r is read, w is write and a is append, the default is read
BUT AGAIN this wont do anything on its own just prep the file.
To test this I did var = open(filename, r)
Then print(var)
and it just gave out this output: <_io.TextIOWrapper name='ex15_sample.txt'
mode='r' encoding='UTF-8'>
basically showing that it has been opened and the type of encoding and mode but
doesnt do anything else.
----------------------------------------------------------------------------------------------------
OPEN has multiple modes:
    'r' : use for reading
    'w' : use for writing
    'x' : use for creating and writing to a new file
    'a' : use for appending to a file
    'r+' : use for reading and writing to the same file
----------------------------------------------------------------------------------------------------
ERROR:EX15 filename.close() AttributeError: 'str' object has no attribute 'close'
That is because that is the WRONG variable it wasnt opened pay attention to the
variable names.
----------------------------------------------------------------------------------------------------
There are many attributes to a string object that you can manipulate these are:
• close – Closes the file. Like File->Save.. in your editor.
• read – Reads the contents of the file. You can assign the result to a variable.
• readline – Reads just one line of a text file.
• truncate – Empties the file. Watch out if you care about the file.
• write('stuff') – Writes ”stuff” to the file.
• seek(0) – Move the read/write location to the beginning of the file.
----------------------------------------------------------------------------------------------------
ERROR: EX16 write takes only 1 argument SO my theory that it will overwrite
itself is wrong and that is ok its good to ask questions it helps to master code
target.write(line1,line2,line3)
TypeError: write() takes exactly one argument (3 given)
----------------------------------------------------------------------------------------------------
Pause a script by placing an input("CONTINUE?") in the code this is not obviously a good idea for
code that needs to run unattended but its very good for ensuring that a code is ran with permission
from a user.
----------------------------------------------------------------------------------------------------
ERROR EX16 Indentation Error: unexpected indent
I guess spacing is an important concept in python
but usually only at the beginning of the lines. EX:
 target.write(line1)
 target.write("\n")
 target.write(line2)
 target.write("\n")
 target.write(line3)
 target.write("\n")
----------------------------------------------------------------------------------------------------
Even though write takes ONE argument
You can use + to get around that!
DONT use commas or you will get the error above!
----------------------------------------------------------------------------------------------------
will the f parameter work with write? It does yes! and it makes it a bit easier
as you dont have to put the +'s and the "" around every \n
target.write(f"{line1} \n {line2} \n {line3} \n")
----------------------------------------------------------------------------------------------------
At this point we can PRINT and we can read and write to files, pretty good really!!! KEEP UP THE GOOD
WORK!!!!
----------------------------------------------------------------------------------------------------
ERROR EX 17: NameError: name 'PRINT' is not defined
I wanted to see if python was case sensitive, looks like that is a YES
----------------------------------------------------------------------------------------------------
You can run functions in print(f"") to do so include them in {} as well
ex: print(f"Does the file exist? {exists(file)}")
----------------------------------------------------------------------------------------------------
REMEMBER input() is a good way to pause a file from executing just press ENTER
to continue with the script. Pretty handy for pausing python until there is user interaction
----------------------------------------------------------------------------------------------------
ACTIVITY Have python run a script creating file objects from log files and searching for errors
in those in a live stream!!!
----------------------------------------------------------------------------------------------------
the len function will calculate the length of a file in storage. It works with
string variables as well len(stringvar) will count the characters in the string
----------------------------------------------------------------------------------------------------
ERROR:EX17.1 When combining open and read in one variable like so:
variable = open(othervar).read()
you CANNOT then perform variable.close() it will fail
I am unsure as to why and I dont even know how to check so I will have to return
to this later to discover.
----------------------------------------------------------------------------------------------------
Python separates multiple code lines by spacing but you can also use ; to
separate code lines cd ../
----------------------------------------------------------------------------------------------------
FUNCTIONS:
IMPORTANT NOTES: User defined Functions have specific rules. They are listed here
1.Must begin with def
2.Function names can only be characters and _'s no other characters NONE OF
THESE !@#$%^&*()-=+;:'",<.>/?[{]}\|
3.Parenthesis go after the name
4.Put arguments in the parenthesis, separate them by commas
5.Arguments have to have unique names
6.The parenthesis end with a :
7.Indent all things the function will do with 4 characters or 1 single TAB
8.DEINDENT at the end

IMPORTANT NOTES: RULES REGARDING CALLING USER DEFINED FUNCTIONS
1.You can run user functions by mentioning their name
2.Just use () after the name with arguments in those ()s separated by commas
----------------------------------------------------------------------------------------------------
ERROR: EX18  print_two("Zed,"Shaw")
                       ^
SyntaxError: invalid syntax

If you look I forgot to close the first argument in a quote
----------------------------------------------------------------------------------------------------
Function arguments are LOCAL only if you call the function and assign arg1 with Hello
and arg2 with There and then you call the function it will show Hello There
BUT if after the function call you attempt to print the value of arg1 it will
show as undefined
----------------------------------------------------------------------------------------------------
ex18.py
Can you declare a variable with the same name? Not really
x=3
x=4
print(f"The value of {x} is: ")
In the above code the first x=3 statement will declare the varibale x
the second will overwrite the value of x to 4 it does not make a new variable
called x.
----------------------------------------------------------------------------------------------------
REVIEW: ex18.py
The below code is confusing seems straight forward but the way Zed described it
made it sound more complicated. He said:
The problem with print_two is that it’s
not the easiest way to make a function. In Python we can skip the whole unpacking
arguments and just use the names we want right inside () .

So what I gather from this is that using *args is essentially asking python to
unpack ALL in the variable args and use it as the parameters for this function

But why is that more difficult? Still not answered but it has something to do
with potential args?

def print_two(*args):
    arg1, arg2 = args
    print(f"arg1: {arg1}, arg2: {arg2}")
----------------------------------------------------------------------------------------------------
REVIEW ex 19.1.py
I get syntax errors when attempt to feed a function an integer which I thought
was strange:
In other words this works:
calculator("90","/","2")
BUT this DOES NOT:
calculator(100,-,6)
I do not know why....
I DO know why its because the function calculator that you made uses eval which takes STRINGS and
performs math on those strings. If you rewrote the function do handle ints by converting user input
to strings like so:
number1=int(input("Enter the first integer"))
Still had to use eval though as operators need a dictionary to get around that
dictionary is a key and a value pair like an associative array in javascript.
SO its a bit advance but not THAT hard, however I will wait till we get there in futher activities.
----------------------------------------------------------------------------------------------------
** is the operator for exponents
----------------------------------------------------------------------------------------------------
ex19.1.py When using inputs they appear as they are in the code. Some coding
languages execute those first but not python which is cool.
----------------------------------------------------------------------------------------------------
You can supply the function with script variables and they do not have to have
the same name as the arguments. But of course they can if you want.
----------------------------------------------------------------------------------------------------
REMEMBER: EX19.py
Does making the variable amount_of_cheese change the variable cheese_count in the function? No,
those variables are separate and live outside the function. They are then passed to the function,
and temporary versions are made just for the function’s run. When the function exits these tem-
porary variables go away and everything keeps working. Keep going in the book, and this should
become clearer.
----------------------------------------------------------------------------------------------------
A variable can reference itself to increase its own value
x = x + 1
To save writign you can do +=
x += 1
Keep your mind open: you can do this with other variables too of course
x += y
----------------------------------------------------------------------------------------------------
EX20.py if we print the entire file then print each line by line WITHOUT rewinding it does the
line by line print nothing as its the EOF(end of file)? Or does it automatically rewind and
the rewind in ex20 unnecessary? REWIND IS NECESSARY otherwise blank values will be given
as I suspected
----------------------------------------------------------------------------------------------------
REMEMBER:
A file in Python is kind of like an old tape drive on
a mainframe or maybe a DVD player. It has a ”read head,” and you can ”seek” this read head
around the file to positions, then work with it there. Each time you do f.seek(0) you’re moving
to the start of the file. Each time you do f.readline() you’re reading a line from the file and
moving the read head to right after the \n that ends that line. This will be explained more as you
go on.
----------------------------------------------------------------------------------------------------
REMEMBER: seek(0) DOES NOT MEAN the first line but rather the first byte keep that in mind
----------------------------------------------------------------------------------------------------
When using readline() the file keeps track of what line is being read. Readline will look
for a \n or a break and gatther that \n then stop and that is how it knows when to return
the output
----------------------------------------------------------------------------------------------------
EX21.py You can of course have function use their return value to supply the argument
to another function:what = add(age, subtract(height, multiply(weight,divide(iq,2))))
As long as they have more than one argument you can daisy chain them like this
----------------------------------------------------------------------------------------------------
REMEMBER: you can declare variables in a print statement by using ,'s or by using +
the ,'s will print on the same line where the + sign will make it appear on a new line
example with commas: print("That becomes: ", what, "Can you do it by hand?")
----------------------------------------------------------------------------------------------------
Why does Python print the formula or the functions ”backward”? Its simple. In excercise 20
all of the functions have both a and b parameters. For parameter a we provide the function
with the variable age. But for the b value we substitute if for another function. We do this
multiple times, linking all of the functions together. Python then goes and says I know the
value of parameter a its age. but the value of b is all of these other functions and it begins
calculateing those based on their innermost parenthesis which is why it works inside
out. Each inner parenthesis must be resolved before it can calculate final value of b.
----------------------------------------------------------------------------------------------------
There are other ways of importing packages:
you can do:
from sys import argv
OR you can do:
import sys
script, input_encoding, error = sys.argv
----------------------------------------------------------------------------------------------------
Inside a function you can daisy chain another function of course as we did before you can even feed
the inside function the same variables as the outside function
def main(language_file, encoding, errors):
    line = language_file.readline()
# if line exists?
    if line:
        print_line(line, encoding, errors)
        return main(language_file, encoding, errors)
----------------------------------------------------------------------------------------------------
if statements begin with if then follow the condition then a : to begin the then statement.
Then indent 4 spaces in manually or with tab and state what will hapen if true.
----------------------------------------------------------------------------------------------------
.strip() - removes spaces and linebreaks at the end of strings
----------------------------------------------------------------------------------------------------
.encode - Encodes to UTF-8 UTF-16 and others like UTF-32 which are computer langs
----------------------------------------------------------------------------------------------------
.decode - decodes bytes back to strings or in other words computer readable to human readable
----------------------------------------------------------------------------------------------------
For ex23.py had to enable utf-8 for all languages on my terminal by running:
sudo dpkg-reconfigure locales
and selecting all.
Then re-download the language file as it affected the entire computer not just the terminal
----------------------------------------------------------------------------------------------------
”DBES” which stands for ”Decode Bytes Encode Strings”. I say ”dee bess” in my head when I have to
convert bytes and strings. When you have bytes and need a string , ”Decode Bytes”. When you have
a string and need bytes , ”Encode Strings”
----------------------------------------------------------------------------------------------------
 In if statements you can do if something: and that will check and see if its not null.
----------------------------------------------------------------------------------------------------
# Without a conventional loop this will loop until the line is null and that is kind of amazing
# I didnt even notice this before but the function main keeps calling itself
# making a loop without a conventional loop
def main(language_file, encoding, errors):
    line = language_file.readline()
# if line exists? YES
    if line:
        print_line(line, encoding, errors)
        #calls itself
        return main(language_file, encoding, errors)
----------------------------------------------------------------------------------------------------
REVIEW: errors strict?? Is this some sort of built in error checking?
----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
MISUNDERSTOOD: When using print(f"") its only neccessary when you want to combine strings WITH variables.
You can just do print(var) with no quotes and no f if you just want the var to print.(Tested this)
----------------------------------------------------------------------------------------------------
ERROR EX24.PY:
File "ex24.py", line 23
    def secret_formula(started)
                              ^
SyntaxError: invalid syntax
FORGOT TO ADD A : after the ()'s for the function
----------------------------------------------------------------------------------------------------
=====================================================================================================
REVIEW
=====================================================================================================
After quite some time without using python I decided to review what I have learned so far. Much I have forgotten but only temporarily as
I have simply archived the knowledge and need to refreshen it and not learn it all anew. However i have decided to run each .py script
and also run each section of it to ensure I understand it.

I picked up some things I must have missed the first time and am noting them here in this review section:

The < and > signs will automatically change the returned value to a boolean on their own which I found interesting and probably must be
true in other coding languages as well

EX:
print("How intriguing that it makes the returned values a boolean automatically when running a < or > operation like 3+2<5-7. The
answer of course is",3+2<5-7,".The less sign must change the statement automatically within phython to a boolean return value")
-----------------------------------------------------------------------------------------------------
REMEMBER: when calling functions with arguments you can perform math and even call variables for the
arguments

-----------------------------------------------------------------------------------------------------
REMEMBER: Arguments are place holders nothing more.
The function below has 2 arguments but when you call the function the names of the supplied arguments
can be direct input or variables with different or the same name as the argument itself. For example:

def areaofsq(variable1,variable2):
    print(f"The area of the square is equal to: ", variable1*variable2)

height=10
width=10
areaofsq(height,width)

areaofsq(10,10)

areaofsq(height-2,width-1)


The above code all works!

=====================================================================================================
END REVIEW
=====================================================================================================
THINKOUTSIDETHEBOX

In the below snippet of code which is found in excercise 24 you see that
 you can declare multiple variables at once using a function on the other
 end like so
 beans, jars, crates = secret_formula(start_point) # declares 3 variables
 and assigns them the function result
-----------------------------------------------------------------------------------------------------
Also in ex24.py is the ability to assign multiple brackets values by
assigning the return of the secret_formula function to a variable and then
leaving blank brackets in a print statement and filling them in with .format
the use of an * to assign multiple values is quite clever
formula = secret_formula(start_point)
print("We'd have {} beans, {} jars, and {} crates.".format(*formula))
-----------------------------------------------------------------------------------------------------
ERROR: EX25.py
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "/home/foss-ter/MYSELF/Python/Exercise/25/ex25.py", line 4, in break_words
    words=stuff.split('')
ValueError: empty separator

CAUSE: Forgot to add a delimiter
RESOLUTION: When using .split('') dont leave it empty put a delimiter in there like so:
.split(' ')
-----------------------------------------------------------------------------------------------------
 didnt know that you can import .py files when doing so first open the python cli by typing
python3.6 and pressing enter
Then use import filename WITHOUT the .py to import variables, functions and whatever else ya
have in that file.
When referencing commands simply prefix the filename like so ex25.myfunction
-----------------------------------------------------------------------------------------------------
So in EX25 we just made a local module without even knowing about it! That is ridiculous!
Well that is really cool and just like with most modules you can run help (modulename) or in this
case help (ex25) and it will print out the comments you made in the code above each function!

When creating the module python will create a dir called _pythoncache_ which I do not know what it
does as of yet save that I know it gets created at the moment the local module is loaded into python.

My guess is that once that is created we can run the code that we ran in the excercise to execute
those functions in the dir where pythoncache is stored and it will check there for the functions wiht
out having to specify ex.function name.

I decided to test this and it failed if I took out the ex25 in front of the functions. BUT I tried
with the ex25 in front and I left out the import and it failed AGAIN

THEN I added the import and it all worked. SOOOOOOOO
long story short you can tun functions from another python script if you import the other script via
import. But why would you do this????

Simple you can divide your functions, methods, conditional statments up for cleaner looking code
Now is it wise for time complexity? Idk it may be an issue, especially with the scale of large
companies.

How can you avoid specifying the ex25 each time that you reference ex25?
change the import statement to from ex25.py import *
-----------------------------------------------------------------------------------------------------
REMEMBER:
When importing modules that you have created, you must reference them using ex25.functionname
-----------------------------------------------------------------------------------------------------
Other insights and notes on ex25 is the split, sorted and pop attributes or functions (whatever they
are)
split will split a string based on some sore of delimiter
sort will sort a string alphabetically and most likely has the ability to sort numbers as well
pop will remove a word from a list of strings. It may be able to remove numbers as well.
RESEARCH: Should pydoc this most likely.
-----------------------------------------------------------------------------------------------------
QUESTION
What is the difference in a method, function and attribute anyway?
-----------------------------------------------------------------------------------------------------
pydoc -b will generate a list of installed modules and their help pages which is really cool so keep
that in mind as a resource for ya.
-----------------------------------------------------------------------------------------------------
When fixing excercise 26 I am proud to say I only had 1 syntax error and 1 logical error the f in a
print statement. And I fixed them all in like 20 minutes, SO I am kind of a big deal now :P
-----------------------------------------------------------------------------------------------------
So booleans are the same and excercise 27 and 28 were pretty painful as it was some PRETTY basic
sh*t you dont even need to be able to code to understand these concepts but having some coding
background with java this was a VERY painful excercise but being the completionist that I am I sort
of completed 28 but I did skip 27 as its a waste of time and energy.... moving on!
-----------------------------------------------------------------------------------------------------
SO just like functions, if statements in python are have colon and all things within the if statment
(except the declaraiton) is indented and the indention determines what is in the then statement.
if 1 != 0: #This is the declaration
	print("I tabbed here!")
var=print("if statement is over")
----------------------------------------------------------------------------------------------------
Its getting a bit tedious at this point (ex30) so from now on I will be skippping excercise and doing
only those that have a point to them and not just repeated information.

I will be annoting new things that I come across here instead of doing the entire excercise to save
time.

EX30
The Else if statement:
elif variable < variable
	print("Someting")

The Else statement
else:
print(something)

EX31
Nested if statements
if somevar == somevar
	print()
	if somevar == somevar
		print()

The nested if is just indented more and so is its "then" statement which is actually an indention of
its own.

I did EX32 as my loop game could use some work
LOOPS and a bit of arrays

DECLARING A LIST IN PYTHON
varname = [1,2,3,4,5,6,7]
# thats all there is to lists really add some qoutes if you want strings
----------------------------------------------------------------------------------------------------
I was wrong about lists they are actually called lists and there are arrays as well. So what is the
difference between them?
----------------------------------------------------------------------------------------------------
DECLARING A FOR LOOP
for i in something:
    print("print or do something here")
The i can be replaced with anything you wish
----------------------------------------------------------------------------------------------------
The while loop continues the block of code over and over again until the statment is false
BY THE WAY the BLOCK of code I mentioned begins with the : and ends once you STOP tabing
Like so
while i<10:
    print("this is the block!")
print("The block is now over with this statment.")

As the while loops checks for a condition its like an if statement! and this is true for all coding
languages and not just with python so keep that in mind.

Same with the for loop it continues until it reaches the end of its iteration and that is true in
other coding languages as well.
----------------------------------------------------------------------------------------------------
DECLARE A WHILE LOOP
i=0
numbers = []
while i < 6:
    print(f"At the top i is {i}")
    numbers.append(i)
	i = i + 1
----------------------------------------------------------------------------------------------------
Excercise 33 hints at the stack without mentioning it by word. The stack of numbers and the top is
the current iteration of the while loop. The stack in coding is the most recent code where the oldest
 code is at the bottom and the newer code lies at the top its a concept that I need to understand
more fully in the future.
----------------------------------------------------------------------------------------------------
Also in ex33 you will change the code to a for loop (functionwhileloop.py)
What I learned when doing this with a range for loop is that the incremental user input doesnt matter
The array will include a solid list from the start number zero till you reach the number given by
the user to stop at minus 1. That being said, on the very first iteration i does increase by the
increment value but it then stops. I am still analyzing why....

Here is the code for ease of access:

def userinputwhileloop():

    i=1
    loopuntil= int(input("Enter an integer at which the loop will stop: "))
    numbers = []
    increment_value = int(input("Enter a value the code increments by:"))
    for i in range(0,loopuntil):
        print(f"At the top i is equal to {i}")
        numbers.append(i)
        i += increment_value
        print(f"What is the value of i? {i}")
        print("Numbers now: ", numbers)
        print("At the bottom i is {}".format(i))
      print("The numbers: ")

    for num in numbers:
      print(num)
userinputwhileloop()
----------------------------------------------------------------------------------------------------
So I modified the code and moved the incrementvalue BEFORE the numbers.append(i) and now the start
of i is different and its actually stored in the numbers list but it still wont increment by 5,
 all it did was add 1 to the value after the first iteration. Still odd but I am going to continue
with the excercises so I can move on.
----------------------------------------------------------------------------------------------------
LOGICAL ERROR!
In excercise 35 I forgot to tab over the conditional statements in a while true loop.
for example
there was a function
def somefunction():
    somevar=True
    while somevar:
        choice = input(":")
    if choice == "Somthing":
    	somevar=False
	exit(0)

In the above code you can see where I messed up at. Essentially I forgot to tab over the if statment.
So the while loop was always true so it kept prompting for user input and it never reached the if
statement below it!
----------------------------------------------------------------------------------------------------
Every if statment apparently must have an else statement. Is that true? Or is that more of a best
practice? Lets test it!

It's a best practice and honestly it should be required
----------------------------------------------------------------------------------------------------
Never nest more than 2 deep and try to do it in one nest
if
    if
----------------------------------------------------------------------------------------------------
Even if you dont call them functions cannot remain empty!!!!!
I didnt know that!!
----------------------------------------------------------------------------------------------------
When working with booleans and user input remember that even if you ask the user to input True or
False the variable will remain true as it exists... I have even tried converting it to a boolean
and it still doesnt work its always true. Instead you should use a function that will return True or
False.
----------------------------------------------------------------------------------------------------
REMEMBER THIS AND READ IT AGAIN AFTER MESSING WITH CLASSES!!!!
You have learned about lists. When you learned about while-loops you ”appended” numbers to the
end of a list and printed them out. There were also Study Drills where you were supposed to find all the
other things you can do to lists in the Python documentation. That was a while back, so review those
topics if you do not know what I’m talking about.
Found it? Remember it? Good. When you did this you had a list, and you ”called” the function append
on it. However, you may not really understand what’s going on so let’s see what we can do to lists.
When you write mystuff.append('hello') you are actually setting off a chain of events inside Python
to cause something to happen to the mystuff list. Here’s how it works:
1. Python sees you mentioned mystuff and looks up that variable. It might have to look backward
to see if you created it with = , if it is a function argument, or if it’s a global variable. Either way it has to find the mystuff first.
2. Once it finds mystuff it reads the . (period) operator and starts to look at variables that are a
part of mystuff . Since mystuff is a list, it knows that mystuff has a bunch of functions.
3. It then hits append and compares the name to all the names that mystuff says it owns. If append
is in there (it is), then Python grabs that to use.
4. Next Python sees the ( (parenthesis) and realizes, ”Oh hey, this should be a function.” At this
point it calls (runs, executes) the function just like normally, but instead it calls the function with
an extra argument.
5. That extra argument is ... mystuff ! I know, weird, right? But that’s how Python works, so it’s
best to just remember it and assume that’s the result. What happens, at the end of all this, is
a function call that looks like: append(mystuff, 'hello') instead of what you read, which is
mystuff.append('hello') .
----------------------------------------------------------------------------------------------------
REMEMBER: WHEN DO I USE A LIST?
1. If you need to maintain order. Remember, this is listed order, not sorted order. Lists do not sort
for you.
2. If you need to access the contents randomly by a number. Remember, this is using cardinal num-
bers starting at 0.
3. If you need to go through the contents linearly (first to last). Remember, that’s what for-loops
are for.
----------------------------------------------------------------------------------------------------
REMEMBER!
When using negative numbers on the index for a list that will reverse the order that the list is
referenced. For example:
mylist = ["first", "second", "Third" , "fourth"]
print(mylist[-1], "This will return fourth or the VERY LAST item in a list!")
Think of the list as having a zero at the end that is not INSIDE the list as -0 is just 0 or he first
character of the list.
----------------------------------------------------------------------------------------------------
PYDOC LIST is an amazing list of all attributes that lists have. So when you need to work with lists
Review that information!
----------------------------------------------------------------------------------------------------
A list is declared like so mylist = ["item1", "item2"] etc....
----------------------------------------------------------------------------------------------------
Join will join the list items together in a single string. You can specify a delimiter that will
insert itself between each column, like so:

mylist = ["first", "second", "Third" , "fourth"]

print("|".join(mylist))

This would print first|second|Third|fourth

----------------------------------------------------------------------------------------------------
Lists have a method called insert that will insert an item in the list at a given point in the array
like so:
myarray[1,3,4,5]
myarray.insert(1,2)
----------------------------------------------------------------------------------------------------
Other List properties are .delete(array_#),.pop(# or leave blank for last element), .remove(value),
.sort(), .reverse(), min(myarray), max(myarray) and sum(myarray)
----------------------------------------------------------------------------------------------------
Dont forget the list function that will take a string of things and turn it into a list. You usually
use this with range but it can be usedwith anything, numbers, strings ANYTHING and dont forget it!
----------------------------------------------------------------------------------------------------
Data Structures are a way to structure or organize data, that is really all there is to it! Not to
say that the data structures dont get stupidly complex, keep that in mind that they organize data.

You have been using a simple data structure this whole time, its called a list!
----------------------------------------------------------------------------------------------------
The author compared a list to a deck of cards which made it a little easier to understand how to
break down a complex data structure (not that a list is complicated) its a good strategy for breaking
down complex data sructures to things we see everyday in the realworld.
----------------------------------------------------------------------------------------------------
Dictionaries are just like assocaitive arrays in javascript they are value and key pairs, There isnt
much of a difference between a list and a dictionary except lists use brackets or []'s and are in
order while dictionaries use {}'s or braces.
----------------------------------------------------------------------------------------------------
Dictionaries are like lists in that they are a DATA STRUCTURE!
PYDOC DICT to find more info!
----------------------------------------------------------------------------------------------------
Objects are a way to store functions, for loops and really any other code that you want into a block
There are different types of obhjects but for lesson 40 we the object we want is a class.
When you write code for an object and then call it you are actually creating that object for the
first time. If you call it again it creates another object that is completely different that the
previous one. They are separate objects at that point. Its strange but I didnt know this.
----------------------------------------------------------------------------------------------------
Creating an object its called instatiate which is the equivalent in python. When you create an object
in most coding languages you have to create it calling that class you made. To do so you MUST assign
it to a variable. The name of that var doesnt matter. For example: var = MyObject() When calling a
function from the object you created you will need to do
varthatwasassignedtotheobj.functioname(parametersifany).
----------------------------------------------------------------------------------------------------
We are gonna drill a little deeper into what happens when instantiate a new object:
1. Python looks for MyStuff() and sees that it is a class you’ve defined in your import above
2. Python crafts an empty object with all the functions you’ve specified in the class using def.
3. Python then looks to see if you made a ”magic” __init__ function, and if you have it calls that
   function to initialize your newly created empty object. UGHH I hate when they dont know so they
   just call it magic or they are too lazy to explain it to me, freakin annoying. It looks like that
   __init__ is a keyword for python and initializing objects. You can pydoc __init__
4. In the MyStuff function __init__ I then get this extra variable self , which is an empty object
   Python made for me, and I can set variables on it just like you would with a module, dictionary,
   or other object.
5. In this case, I set self.tangerine to a song lyric and then I’ve initialized this object.
6. Now Python can take this newly minted object and assign it to the thing variable for me to work
   with.
7. Classes are like blueprints or definitions for creating new mini-modules.
8. Instantiation is how you make one of these mini-modules and import it at the same time.
   ”In- stantiate” just means to create an object from the class.
9. The resulting created mini-module is called an object, and you then assign it to a variable to
   work with it.
----------------------------------------------------------------------------------------------------
Excercise 40 reminds me of when I was doing plsql when we did the goblin,orc and elf object things
In fact its very similar as we had a base object and from that base object we created nested objects
from that object. So while there were 7 types of elves, they were all elves. The base elves all
had a name and a race. SO the base would have what they have in common and the children of that base
just inheritted the object values of that base.
----------------------------------------------------------------------------------------------------
So I think the __init__ function specifys what parameters that Song should have when its called.
----------------------------------------------------------------------------------------------------
OBJECT VOCAB and DEFINITIONS
class Tell Python to make a new type of thing.
object Two meanings: the most basic type of thing, and any instance of some thing.
instance What you get when you tell Python to create a class.
def How you define a function inside a class.
self Inside the functions in a class, self is a variable for the instance/object being accessed.
inheritance The concept that one class can inherit traits from another class, much like you and your
parents.
composition The concept that a class can be composed of other classes as parts, much like how a car
has wheels.
attribute A property classes have that are from composition and are usually variables.
is-a A phrase to say that something inherits from another, as in a ”salmon” is-a ”fish.”
has-a A phrase to say that something is composed of other things or has a trait, as in ”a salmon
has-a mouth.”
----------------------------------------------------------------------------------------------------
So the vocab on objects is a little strange, it all depends on the context. For example a class is
a type of object but when you drill down into specifics that definition is confusing. When you have
a class called Fish and a class called Salmon with inheritance on that Fish class. So far so good
until you create an instance. That instance is also called an obnject, because it was created by a
class which is an object. When I say it like this I realize its not really confusing after all.
----------------------------------------------------------------------------------------------------
What is inheritance? Inheritance is when you have a base class and create a class that uses that base
class as its starting point. What this looks like in code is class Humanoid(object); pass
class Elf(Humanoid); pass

If I had given Humanoid a function instances created by the Elf class could call that function.
----------------------------------------------------------------------------------------------------
What is is-many or multiple inheritance? Well if I expanded on the elf class above and did
class Drow(Elf); pass and if I then did Drizzit = Drow() then that would make drizzit inherit 3
different classes, namely humanoid, Elf and Drow. Doing this is apparently a bad idea because it can
get confusing to humans.
----------------------------------------------------------------------------------------------------
super will run a function from the parent, but what happens when you have 2 parents? is it super
super??
----------------------------------------------------------------------------------------------------
So what is the __init__ function and what is self??
Well I searched this online and __init__ is a reserved method in python.It behaves like a contructor
of the class and it should be the first method that is called when you run the script. Everytime an
instance is created it calls the __init__ method which is cool! Usually you have to destroy created
objects but that is not neccessary in Python. So __init__ can have requirements when you create
instances so for example an init with self, height, weight as the parameters would need to be created
with those same paramters excluding self. So you couldnt do instance = classname() instead you would
do instance = classname(5'11, 210)

So what is Self? its actually just a naming convention for the first attribute for the init class you
could rename it to what ever you wanted but you would then need to use it when assging values of the
attributes to the instances themselves.

Lets give an example because this is too hard to do with out one:

class cargenerator(object):
    def __init__(self,speed,color):
        # Without using self.speed if you tried the print statement below it would fail as it doesnt
	# exist.
	self.speed = speed
	self.color = color

car = cargenerator(250,'red')
print("The car's color is " ,car.color)

So in the above example we could have changed the value of the init function parameter to ANYTHING
But then when we assign the speed to itself we would need to change self.speed to whatever we set
the first parameter to the __init__ function to. As such self is just a convention. The first
argument of __init__ is the "self" argument.

But why is it needed to assigned speed to self? Isnt that obvious? No, not to Python it isnt. If we
tried to print out the value without assigning it then python wouldnt know what you wanted it would
return the error: AttributeError: 'cargenerator' object has no attribute 'color'

When creating an instance you dont have to specify self just the values of the other parameters.
Alternatively you could do a car.color = red and car.speed = 300. its good to know multiple ways
in which to do the same thing.

P.S. pass is used to create an empty class or block. A block of code is the indented regions that in
python begin with a : when you use def, if for and other colon ending built in things.
----------------------------------------------------------------------------------------------------
What is Super?
Super is used to call functions (or whatever you want) from parent classes that the current class
you are in needs access to. This includes attributes and anything really.
----------------------------------------------------------------------------------------------------
When it comes to creating your own application you can use the following steps to help you get
started:
Write or draw about the problem
extract key concepts from 1 and research them
create a class heirarchy and object map for the concepts
code the classes and a test to run them
repeat and refine
----------------------------------------------------------------------------------------------------
INHERITANCE

class terd(object):

    def demonstration():
	print("This is a parent function that can be called by inherited children")

class terdlet(terd):
    pass

terdlet.demonstration()

In the example above we learn that ALL CHILDREN of PARENT objects inherit all functions of the parent
Not just functions but attributes and anything else
----------------------------------------------------------------------------------------------------
INHERITANCE CONTD

But what if we want to override the value of a function because it should act differently on the
CHILD than it does with the parent? In that case we can simply use the same name of that function
defining it on the child and that will overwrite it on the CHILD without affecting the other CHILDREN
if any.

class terd(object):

    def demonstration():
        print("This is a parent function that can be called by inherited children")

class terdlet(terd):
    def demonstration():
        print("This is a child function that overwrote the parent function")

print("The parent demonstration function")
terd.demonstration()
print("The child demonstration function")
terdlet.demonstration()
----------------------------------------------------------------------------------------------------
Then there is the super command. The super command is a way to access the original parent function of
a child overwritten function that has that same name. The syntax of super I find strange though. For
EXAMPLE:

class Parent(object):

    def demonstration(self):
        print("This is a parent function that can be called by inherited children")

class Child(Parent):
    def demonstration(self):
        print("This is a child function that overwrote the parent function")
        print("Child after super")
        super(Child,self).demonstration()


dad = Parent()
son = Child()

print("The parent demonstration function")
dad.demonstration()
print("The child demonstration function")
son.demonstration()

You will notice that this time we actually created an instance, that is because super needs an
argument which can be something other than self (I believe) but in this case I used self. To use self
You must create an instance from the class like so:
mary = salmon()
without doing so self doesnt exist as there is no instance.

Any way the output of the above command is:

The parent demonstration function
This is a parent function that can be called by inherited children
The child demonstration function
This is a child function that overwrote the parent function
Child after super
This is a parent function that can be called by inherited children

So we see that after using super(Child,self).demonstration we get the parents output. What I find
confusing about it is why it isnt super(Parent,self).demonstration, afterall we want the parents
function, not the childs...

SO I pydoced super and I could only make out that its class then first argument which is self. I then
googled super and found out the use case for it. Super is used to get the parent class function of a
parent that you dont know the name of. So when working with other peoples code and you are diving
deep to understand how the function evolved from parent to child but you cant find the parent name
Then you can do call super to just grab the parents name based of the child class's name!
----------------------------------------------------------------------------------------------------
I also researched multiple inheritance, and I got a different opinion than the author. The opinion I
got was that inheritance in python 2.2 was bad but we are on 3.7 and its a much different horse and
it works good now.

btw this is what multiple inheritance looks like:

class bigboy(Parent1,Parent2)

So when that happens, how does super know which parent to choose from? Its like a divorce and the kid
has to choose!

Well super in the background uses something called Method Resolution order that is a complex and well
defined algorithim that picks the right function from those 2 parents when running super.
----------------------------------------------------------------------------------------------------
I wonder if super overwrites it permanently.... That I dont know. But I think maybe...
----------------------------------------------------------------------------------------------------
The most common use of super is to use it to modify the __init__ function of the base class parent
for example say you need this child to be a parent of some other class. So you override the parent
__init__ function and new attributes in the __init__ but you still want to access the first parents
__init__ so you use super at the end of your overwritten __init__ like so:

def __init__(self,stuff):
    self.stuff = stuff
    super(Child, self).__init__()
----------------------------------------------------------------------------------------------------
Then there is Composition. Compositions is a way to call other object attributes, functions, you
name it from another object. Its essentially a work around to inheritance.

This looks like this in code:

class notaparent(object):
  def __init__(self):
    print("initialize from notaparent, includes self")

class notachild(object):
  def __init__(self):
    self.norelation = notaparent()
    print("Initialize from notachild, includes self")
    print("Now we will call the other funtion's __init__")
    self.norelation.__init__()
comp = notaparent()
osition = notachild()

The above code just calls the __init__ function of both objects and its possible due to creating an
object from the init function inside the notachild class.

So composition is how you create objects in objects so that one object calls other objects in its
creation.
----------------------------------------------------------------------------------------------------
ERROR: This error occurs when you assign a class to a var and initialize an object and include self
in the call like so
someinstance = Class(self,anattribute)
It doesnt work because self in this case is implied
TypeError: __init__() takes 1 positional argument but 2 were given
----------------------------------------------------------------------------------------------------
WHEN TO USE INHERITANCE OR COMPOSITION (according to Zed)
1. Avoid multiple inheritance at all costs, as it’s too complex to be reliable. If you’re stuck with
it, then be prepared to know the class hierarchy and spend time finding where everything is coming
from.
2. Use composition to package code into modules that are used in many different unrelated places
and situations.
3. Use inheritance only when there are clearly related reusable pieces of code that fit under a
single common concept or if you have to because of something you’re using.
----------------------------------------------------------------------------------------------------
METHODS
Functions that reside in classes are called methods. Its mostly a marketing term (haha)
As such we should name functions like they are commands not by what they do. Which is an intersting
concept and one that makes sense. For example pop, its literally a method and its not called
remove_the_last_item. Because that doesnt sound like a command.

be consistent with arguments, if they you have functions that take arg1, arg2, arg3 dont be the guy
that decides to do arg3 arg1 arg2 ok?
----------------------------------------------------------------------------------------------------
PIP, WHAT IS IT?
Pip is a way to install modules from online which are just scripts that others have worked on to
make tools that you may use as well. To save space on your device not all modules are installed
as such if you want a particular module you need to install it with pip. pip3.6 install modulename
----------------------------------------------------------------------------------------------------
VIRTUAL ENVIRONMENTS
Virtual environments are a python tool for dependency management and project isolation. They install
dependencies also called site packages which is also called 3rd party librarues these are installed
locally in an isolated dir for a particular project.

SO WHAT IS IT???
Its just a directory with 3 components:
A site-packages folder - where 3rd party are installed
Symlinks to Python executables installed on your system
scripts that ensure executed python code uses the python interpreter and site packages installed
inside the virtual environment.

This is just like docker, you create a virtual environment similar to a virtual machine but more
like a mounted directory that acts like a separate environment to your local machine.

Virtual Envs work because it modifies your path so that code will run from different path varaibles

----------------------------------------------------------------------------------------------------
If you are returning to this function we needed to first install virtualenv with
pip3.6 install virtualenv
Then we made a hidden dir in home called ~/.venvs
Then we ran virtualenv --system-site-packages ~/.venvs/lpthw
then . ~/.venvs/lpthw/bin/activate
then pip install nose
Now the nose dependency is installed on the environment
----------------------------------------------------------------------------------------------------
UNIT TESTS!
WHY ARE THEY IMPORTANT? Simple AUTOMATION! Pipelines with unit tests ensure that every deployment
is safe from known errors at the time. That is why multiple unit tests are needed. To expand on them
when new errors occur!
----------------------------------------------------------------------------------------------------
I went and looked over the videos and found that they were really helpful so now I am watching them
all. This will take some time but not too long I hope! then I can get back to finishing the book.
----------------------------------------------------------------------------------------------------
print("Some text here {}".format("It worked"))
# We need text around this because it needs to be a string as the attribute format is only used on
strings
formatter = "{} {} {} {}"
# This needs to be in a print statement because it needs to return to stdout.
print(formatter.format(1,2,3,4))
----------------------------------------------------------------------------------------------------
* can be used to pull all data points from an array, list or LITERALLY anything with multiple data
points. For example:
myarray = [1,2,3,4]
print(*myarray)
# This would print 1 2 3 4
----------------------------------------------------------------------------------------------------
I was testing end =' ' and found that I cannot use end unless its at the end of the print statement.
This is good to know as it gives a vague error:
>>> print("Here\'s a test \a\a\a\a\a\a", end= ' ', "Hello?")
  File "<stdin>", line 1
SyntaxError: positional argument follows keyword argument

From the context it looks like end is a keyword argument and then there is positional arguments i
which I assume are the commas.
----------------------------------------------------------------------------------------------------
You can use repr(var) to print the string equivlalent of a varibale or object.
---------------------------------------------------------------------------------------------------
I should make a coding ideas section for well coding ideas....
---------------------------------------------------------------------------------------------------
When you assign things to argv, you are actually giving variables to argv and they can be treated
like variables so you can print them out or return them or what ever you want with those variabeles
---------------------------------------------------------------------------------------------------
When you run print statements with the f string you can run commands on the varibales like int
or whatever you want which is really useful. For example
my array = [1,2,3,4]
print(f"The last element of the array is {myarray.pop()}")
Which ius really handy!
---------------------------------------------------------------------------------------------------
Learn the mentality or get in the mindset of if you can do one thing with one thing in python you
can most likely do it wiht another thing!
---------------------------------------------------------------------------------------------------
In excercise 18 I didnt even realize that * was used nor did I see the var1 , var2 = alist
It was so similar to argv that I thought that it was argv but it was just a list!
---------------------------------------------------------------------------------------------------
CONFIRMED positional arguments are those that are separated by commas.
---------------------------------------------------------------------------------------------------
Rundeck runs on linux that is kindo of like a cron job for multiple servers
---------------------------------------------------------------------------------------------------
ANYTHING AFTER a return is ignored because the function terminates!!! I did not know that!
---------------------------------------------------------------------------------------------------
When running from sys import argv sys is most likely a directory you see this in ex 46-48 as you can
import the entire directory if you want to.
---------------------------------------------------------------------------------------------------
Orthogonal - self similarity - you can nest the same things and different things
nested ifs functions inside functions. That is a theory that  I need to expand my mind with
---------------------------------------------------------------------------------------------------
argv is just a list btw you can even do argv on py
---------------------------------------------------------------------------------------------------
So I found this potion of ex32 video that confused me but I was able to work it out when I wrote it
down. This is the example that had me confused:
y=["a","b","c","d"]
i=10000000
y[i % len(y)]

When I ran that it equaled a and it confused me because I forgot about modulus how it will take the
remainder of something. Breaking that down further it basically says give me the index at
The remainder of 1000000/the length of y(4) and because its a 10000000000 number it will always be
0 which means y[0] or a
---------------------------------------------------------------------------------------------------
When copying an array or when you want everything in a list you should do [:] When you want a
specific range you can do [3:4) That would grab the 4th Element of a list.
If you want a range say 2-4 in a list yo u would do [2:4]a
when using [] it doesnt start with zero which threw me.
ex:
y=[1,2,3,4,5]
# Say you want 3-4
# Then you would do:
range=y[2:4]
print(range)
#You can even do
range = [:3] To get the first 3 elements
range [3:] To get 4 and 5
That is really cool! Now thing that you can do function calls within that and variable calls too!
---------------------------------------------------------------------------------------------------
The variable I used above is actually a command so dont forget that!
range(start, end, interval)
ex:
list(range(1,10,5))
1
6
Range default interval is 1 if not specified
Also list will create a list for you from the output of something.
---------------------------------------------------------------------------------------------------
strip is an attribute on string output that removes spaces or line breaks
---------------------------------------------------------------------------------------------------
Why learn how to do things different ways in linux and coding????
Because its all about efficency and time complexity, ram and compute power that is why!
---------------------------------------------------------------------------------------------------
Zed uses repr in a print statement alot to debug. But IDE built in debug tools are probably better.
---------------------------------------------------------------------------------------------------
Be careful when you declare a block in python, it doesnt have a precompiler like java and C. That
means its more like procedural laguage. So the placement of functions and other blocks matter. For
example you cant do:

myfunction(10,30)

def myfunction(num1,num2)
    return num1 * num2

The above code would error out because python gets to the first line and says Oh this a function
call I should look for my function in the code that is before the declaration, but the function
doesnt exist yet so it errors out saying myfunction does not exist.

This is the same with everything in python. Everything is top to bottom format meaning you make
the functions and variables then you can manipulate them all you want, so keep that in mind.
---------------------------------------------------------------------------------------------------
PRINT ALL VALUES OF ARRAY WITHOUT NEW LINE:
usually when you have an array and you make a for loop to print it out it shows up like this
a
b
c
d

What if you want a b c d?

Then you would do

y=["a","b","c","d"]
for eachitem in y:
    print(eachitem, end=" ")
TADA! a b c d
---------------------------------------------------------------------------------------------------
DID YOU KNOW?
That the incremental variable in a for loop is created for you inside the code for the for loop?
yes I did know that BUT I didnt know that the variable is not deleted once the loop completes its a
global variable and can be called/used after the for loop runs. The value of i is whatever the value
was at the end of the loop as it is overwritten in the loop process.

SO WHY DO I CARE?
Well if you combine for loops and breaks and if statements you can have an interesting looking for
loop that may very well be useful one day!
---------------------------------------------------------------------------------------------------
LOGICAL ERROR on ex35
I had an error on ex 35 where I called the function dead like this:
dead:("You stumble around the room until you starve.")
This function was supposted to trigger when i died but because it had that : when called it never
went off. I never saw that because I didnt test the dead paths (who wants to die right!) And this
same thing could and would happen in other scenarios so that is why you need unit testing!

QUESTION - But what did function:() do? Why didnt that error out??
Lets investigate that later
---------------------------------------------------------------------------------------------------
Revewing the code on EX35 when I missed a hidden gem which is the word in
That simple beautiful word is basically a contains statement. So when you want to take some input
from a user and have something trigger off their phrase you dont have to specify what EXACTLY to
type in. You just have to say if whatever they enter contains the word punch, then run the if
statment below. PRETTY HANDY MY FRIEND. Of course we dont want to think of using this with JUST user
input, that would be thinking small. We can use this with piped commands, logs that contain some
hideous string we wish to filter and anything you can think of. With just one word I can now do ex49
--------------------------------------------------------------------------------------------------
I love the concept that this book teaches which is break GIANT problems into smaller ones. What
noobs dont realize is that this is teaching us to think like an agile developer and teaches you how
to work in a team of developers all working on pieces of the GIANT puzzle. That concept is really an
important one and a good way to think like a developer.
---------------------------------------------------------------------------------------------------
I dont think I have written about try and except blocks
These are used to print out errors of your own creation. This is often used to created a black box
so that malificent users who attept to find vulnerabilities in your code have a harder time
identifying those vulnerabilies because it wont print the coding languages generic error that could
identify the version of python in use.

Try blocks can include anything you want in them if statements, arrays, functions you name it.
Remember anything thing in python can be used with something else in python. Include that philosophy
when dealing with other languages as well to continue to learn and grow!

To declare one just do
def test():
    try:
        var = "not a number"
        int(var)
    except:
        print(f"ERROR: {var}")
test()
----------------------------------------------------------------------------------------------------
Review the % codes in excercise 37 as they are used in all coding languages which is really cool.
Its mostly formating but it could be fun to review.
----------------------------------------------------------------------------------------------------
Just a review when you declare an object and then put a function inside of it the first parameter
of that function has to be self or whatever you named the first variable of the __init__ function
of the class. If you attempt to define a function without any parameters def func() it will error
out with TypeError: func takes 0 positional arguments but 1 was given
Now this can be really confusing as you supplied func with zero parameters in your call but python
is saying it has one.

Why does this happen well when the __init__ is not declared in the class a default hidden __init__
is still declared with self as one of its parameters. Then that self is automatically passed to the
function when called

How do I fix it?
It is quite an easy fix all you have to do is when declaring a function or WHATEVER it is that has
parameters just require to run it with self like so:
def myfunction(self)
    dosomething = ""
    return dosomething

BUT HERE IS ANOTHER CATCH when you call it, call it as if it had no parameters
a = something()
a.myfunction()

I know its confusing but that is life

THERE IS A WAY AROUND THIS and that is to not create an instance at all and just do
something.myfunction() or something.function("Hey you!")
and it will work lol!
----------------------------------------------------------------------------------------------------
This all relates to whether or not its an instance or not. SO RECAP
If you made an instance you need self
If you run class.function you dont.
easy enough when you put it that way.
----------------------------------------------------------------------------------------------------
Reviewing excercise 38 I remembered that I have not taken notes on the ability that f has to run
whatever python code you want inside of it. A good example of this is in ex38 where Zed runs the
length attribiute inside an f. Experimenting with this myself I have found that you can put whatever
you want inside an f"{}" you are only limited to your imagination but it does reduce the readability
of your code to be sure!
----------------------------------------------------------------------------------------------------
CHALLENGE/IDEA
Write a python code that will take user input and send it to a file and run that file. This is going
to be used to refresh your python skills once you have moved on to other languages. This will help
you become familiar once agian with the syntax of python, that is its objective. Python teacher!
----------------------------------------------------------------------------------------------------
A term I am unaware of so far is referential data, when you assign something to some value you are
creating meta data about that data called referential data. This is how python stores your variables
and other things like dictionaries. This goes for functions too as they are created with a name.
----------------------------------------------------------------------------------------------------
When you want to add a value to an existing dictionary you dont use .append or some other builtin
function that you have seen in the past. Instead you declare it like so:
cities['NY'] = "New York"

That will add a dictionary value to the existing dict called cities. With the key being NY and the
value of New York
----------------------------------------------------------------------------------------------------
All dictionaries have the following methods mydict.keys() and my dict.values(). These can be used to
isolate the key and value pairs! They also have mydict.items() for nested dictionaries.
----------------------------------------------------------------------------------------------------
Remember that you can nest dictionaries and can use variables and can use things with other things
of course!
----------------------------------------------------------------------------------------------------
dictname.items - will show all of the items in a dictionary. This is quite useful when dealing with
dictionaries that you havent worked with in some time or that you didnt create.
----------------------------------------------------------------------------------------------------
So real quick I need to practice this but you can do list(dict.items())
SO what that will do is divide up the values of the dictionary and assign them to a tuple with two
values per list slot. This looks like this when done:
mydictlist[(key0,value0 ),(key2,pair2),(key3,pair3),(key4,pair4)]

Essentially this will convert the dict to a tuple(uneditable list) and as such it will allow you to append, join,split
or whatever else you want done on it! When finished I am sure there is a way to turn it back into
a dict with a for loop or something
EXCERCISE Turn a dict into a list make some adjustments and then turn it back into a dict!

Once its in list form you can do
x,y = mydictlist[0]
That will assign the values x to the first half of the dict/list and the value y to the second
for x, y in len(mydictlist-1):
    backtoadict={"x" : "y"}
DONE! Basically did the excercise
----------------------------------------------------------------------------------------------------
dictname.get("keyname") or dict["keyname"] Both of these will return the value at the key name
specified. The difference being is the latter will error out if it doesnt exist and the get wont.
Get proves really useful when you want to check if that dict exists and if it does/nt do something.
----------------------------------------------------------------------------------------------------
When using python from the cli idents can sometimes be ignored.. Intersting! Dont forget
experimenting with the ;
----------------------------------------------------------------------------------------------------
OOOOOOKAY, Zed just blew my mind hole in ex40.py

He showed me some very cool deep understanding of python which is how to show the dicionary keys of
all the things that python keeps track of. I dont quite understand it but when importing a module
back in ex25 that action of importing a module modifies a dunder dict dunder or doubleunderscore
dict double underscore. This __dict__ is a list of all imported libraries and their functions
WHAT IS COOL ABOUT THIS?
Well go right now and open python3.6
type in this to show all of the objects? (idk what to call `em):
import sys
sys.__dict__
Watch as your screen fills up with so much metadata!
TO make it easier to read why not do
sys.__dict__.keys()
This will show all of the things that you can call with sys!

So when you are checking out a module you can do this and find what you can do with that module!!!!

VERY NICE RIGHT!

As I though argv is in there. That is so cool!

Well if you imported 25 you would see all of the functions from ex25 as well.
----------------------------------------------------------------------------------------------------
That was not all he showed in that video he also showed global() Global shows all of the global vars
that python is keeping track of right now!
----------------------------------------------------------------------------------------------------
Now that you know about __dict__ you now know that when you run a function from a module python
checks the dictionary for where to find that value
For example
import 25
25.myfunction()
That will make Python check its dict then it will now where to retrieve that command!
----------------------------------------------------------------------------------------------------
 Make sure you REVIEW excercise 41 for sure!
----------------------------------------------------------------------------------------------------
The way you start with OOP projects according to Zed in ex43 is to jot down the nouns and then see
if any of those nouns have like things in common. When they do you group them together in a
heirarchy, that heirarchy becomes your skeleton for the project you are working on!
----------------------------------------------------------------------------------------------------
When using f you cannot declare variables, so keep that in mind! Also when importing a python file
that has function calls in it, those will run so if you want to reuse your functions from that module
you will need to remove the funciton calls.
----------------------------------------------------------------------------------------------------
An API is not as scary as I thought its just a created set of functions, procedures, methods and
classes used by computer programs to request services from the OS. You use the API to make
applications.
----------------------------------------------------------------------------------------------------
When using Java Zed says that its best to use inheritance but with most other langauges compositon
is easier to use.
----------------------------------------------------------------------------------------------------
ACTIVITY - Investigate multiple inheritance, print out self in ex44 or any excercise that has
inheritance. Get a deeper understanding of what self is.
----------------------------------------------------------------------------------------------------
ACTIVITY - DO EX 45 you skipped it bad Jeremy
----------------------------------------------------------------------------------------------------
Yak Shaving - doing a bunch of work that should of been documented but wasnt because the developer
assumed it works for me so it works for eveyone :P
----------------------------------------------------------------------------------------------------
I learned something about how try and except blocks work.
You can use an error catcher within the except block that has a specific name such as ImportError
If you put whatever you want in there instead it errors out.

try:
    import somethingherethatdoesntexist
except ImportError:
    from sys import exit
----------------------------------------------------------------------------------------------------
print(*var)  - take any nunber of args
print(**var) - take any number of option arguments
QUESTION WHAT IS THE DIFFERENCE BETWEEN optional arguments and the other one?
----------------------------------------------------------------------------------------------------
Python setup.py install from the cli will install your pacakge that you created in ex47 and 48
This is how you make pacakges that other can download through pip
----------------------------------------------------------------------------------------------------
I decided to go back and print out self on each of the functions in ex44.py. When I did so I learned
something quite important that could bite me in the toochie if I dont remeber it so:

REMEMBER:
If you ever are calling ids based on self KNOW that if you have the parent print out self inside a
function and you call that function and it prints out self. The self that it will print out will
belong to the child. Just PYI
----------------------------------------------------------------------------------------------------
When you want to do composition all you need to do is declare 2 classes that DO NOT INHERIT from
each other (I wonder what would happen if they did though?) Then do:

class composition(object):
    def __init__(self):
        self.other = Otherclass()

    def somefunction(self):
        self.other.somefunction()
So you are setting the value of self to an instance of another's class. Then you just call the
functions you want from the other class by nesting them in the same named functions for readbility,
very cool!
----------------------------------------------------------------------------------------------------
So I learned something pretty important in ex45 when attempting to code my own game I had trouble
understanding Zeds logic of how he created the classes and put them inside each other as a parameter
and it blew my mind. That isnt hard to understand once you separate it out into concepts, a thng in
python can be used with another thing, even as a parameter to another thing.
----------------------------------------------------------------------------------------------------
                            THE 6 GOLDEN RULES OF SELF

OK I have learned a valuable lesson here, which is HOW and WHEN to use self.

First off dont forget to create an instance from an object if you are going to use self

Second, when referencing attributes of a CLASS (just a class) you need to use self.attribute
otherwise you will get a "name" is undefined error.

Third when running a function that is used with an instance. You need to add self to the
parameter declaration. If you dont this will cause that function to error out when called
because it will pass self to the function anyway and when ran it will error out with too many
arguments.

Fourth you must assign all other parameters expected by the function to the instance with
self.parameter_name = parameter_name or python will say that parameter is missing.

Fifth - If you plan on chaining object functions and it starts with an instance then ALL of
the functions will need to include self in the function parameters, DONT FORGET THAT!

Sixth - While inside the definition of the class you should use
self.attibute_name or self.function name. But after declaration and initialization you must use
instance_name.function or instance_name.attribute
----------------------------------------------------------------------------------------------------
To understand objects and how to make them feed into each other I pasted a snippet from ex43 with
commentary on the lines that matter most:

class Engine(object):
# this is the game engine.
    def __init__(self, scene_map):
        self.scene_map = scene_map

    def play(self):
        current_scene = self.scene_map.opening_scene()
        last_scene = self.scene_map.next_scene('finished')

        while current_scene != last_scene:
            print("beginning of the while loop, the current_scene is: ", current_scene)
            # This little variable next_scene_name, I was struggling for a long time trying to
            # objects out and this little guy was hidden in plain sight. I overlooked him because
            # he just runs the enter function on scene but he does one other thing, and that is how
            # the object chaining even works and that is the return. After that entire object runs
            # the if statements, the different calls, it all boils down to one string and that is
            # how this works. That sting just calls the next scene and that is the most crucial part
            # of the engine!
            next_scene_name = current_scene.enter()
            # FINALLY I UNDERSTAND next_scene_name works because of the return in all of the scenes
            # if statements they always return a string, THANK GOD! now I write my own game FREAK!
            print("The next_scene_name is: ", next_scene_name)
            current_scene = self.scene_map.next_scene(next_scene_name)
            print("End of while loop")
        # be sure to print out the last scene
        current_scene.enter()
----------------------------------------------------------------------------------------------------
MORE SELF:
You really cant talk about self enough, so here is a better example of self after using it for a
while. Self is a way to call class attributes whether they are inherited or not. That is the best
definition I have found so far!

I am sure I will evolve my definition of self as I continue but so far that is the most practical
definition I have as of yet.
----------------------------------------------------------------------------------------------------
I learned about return "a string" and using that string as a key value in a dictionary is powerful
from ex 45.py further enchancing my knowledge of a thing can be used with another thing. I really like
that outlook on coding and its quite powerful and leads to out of the box thinking.
----------------------------------------------------------------------------------------------------
In python you can allow a function to take as many args as you want with *args or **kw depending on
what argument you want. (Still need to learn the differences between the 2 arguments!
----------------------------------------------------------------------------------------------------
ValueError is a class and its a category of a class called an exception class.
You can call these at the end of except blocks.
Keyboard interrrupt is also a class! How about that!
----------------------------------------------------------------------------------------------------
Except blocks are kind of like if statements because you can have different classes called for
different errors which is really intriguing. For example

except ValueError:

except KeyboardInterrupt

except:
  print("ERROR")
----------------------------------------------------------------------------------------------------
Alot of Python engineers will use the """ for multiple line comments and just not include it into a
print statement. Pretty clever.
----------------------------------------------------------------------------------------------------
Return is a dangerous thing in for loops, BE ALERT when using return as it will exit the for loop.
Here is a real world example: I was working on making a function that will take a sentence and extract
all of the direction words from that sentence and add them to the tuple but I was only getting the first
one each time I ran my python script. The code is below can you spot the problem?

def scan(sentence):
    words = sentence.split()
    directions = ["south" , "north", "east", "west", "down", "up", "left" , "right", "back"]
    mytuple=()
    for word in words:
        if word in directions:
            mytuple += ("directions", word)
        return mytuple
print(scan("I will go south then north then south then right then down"))

Thats right you included the return in the for loop! STOP DOING THAT JEREMY
----------------------------------------------------------------------------------------------------
The methods: seek, readline and readlines all operate on size in bytes which is difficult to pin down
----------------------------------------------------------------------------------------------------
r.strip l.strip and strip all remove white space from strings. l will remove space from the left
r the right and strip the entire string. Strip is a METHOD and can be declared like so:

somestring = "  yoo oooo oooooo        "
somestring.strip()
----------------------------------------------------------------------------------------------------
When writing large numbers you can use underscores to make the code easier to read for humans like so
140_000_000.
----------------------------------------------------------------------------------------------------
Here is a great place to check coding language popularity!
https://www.tiobe.com/tiobe-index/
----------------------------------------------------------------------------------------------------
You can use commas to declare multiple variables at once like so:
x, y, z = 10, 20, 30

You can also pick multiple items from for loops

for y,j in mydict:
----------------------------------------------------------------------------------------------------
CONVENTION
Use all caps to declare a variable that is a constant, or a variable that should not be changed.
MY_VAR = 10
That is a convention that python devs use to say DONT EDIT THAT VAR!
----------------------------------------------------------------------------------------------------
import this - Zen of Python, enter it into the python module to learn code conventions of python!
----------------------------------------------------------------------------------------------------
Parameter vs an argument:
Parameters are the place holders that functions will require arguments for when ran
Arguments are the actual values that replace those placeholders
def myfunction(parameter1,parameter2)
    print(paramter1,parameter2)

myfunction("Print", "something")
----------------------------------------------------------------------------------------------------
Positional arguments vs keyword arguments:

Positional arguments are separated by commas and must be in a particular order, the arguments must
match the order of the parameters otherwise you will get logical errors. That is why they are
positional arguments, because the order of the parameters matters.

Keyword arguments use the place holders as the keys to the arguments value. They are used in the
actual function call like so:

def somefunc(name, title):
    print(name, title)

somefunc(name = "James", title = "CEO")

What is interesting about key word arguments is that you can assign values to one of the keys in the
declaration of the function like so:

somevar = "CEO"
def somefunc(name, title=somevar):
    print(name, title)

somefunc(name = "James")

Now when you run the function it only needs one argument to run! or you can overrite that value
----------------------------------------------------------------------------------------------------
===================================================================================================
WARNING!!!!!!!!!!!!!!!!!!!!!!
===================================================================================================
When combining positional arguments and kw arguments make sure that you dont mix up the order of the
positional arguments:
For example:

somevar = "CEO"
def somefunc(title=somevar, name):
    print(title, name)

somefunc(name = "James")

As title is first the function will overwrite the value of title to James and will error out becuase
name wont have a value.
----------------------------------------------------------------------------------------------------
One of the reasons that we have key word arguments is the ablility to have an optional parameter.
If you assign that parameter a default value in the declaration of the function you will not need
to define that parameter at function call.

For example:
def names(first_name, middle_name = "", last_name)
    print(f"Your full name is {first_name} {middle_name} {last_name})
    #yea yea two spaces get over it do an if statement mr perfect
names("James","Jonas")
----------------------------------------------------------------------------------------------------
As you know [:] will select all of the items from a list, or that is what I thought it did. What it
actually does is make a copy of that list. This can be used to your advantadge when you pass a copy
to a function (in the function call) like so:
the_original = [1,2,3,4,5]
def myfunction(some_array)
    some_array.pop()
    print(some_array)

myfunction(the_original[:])
print(the_original)

If you call that function you will notice that the original remains the same
----------------------------------------------------------------------------------------------------
def make_a_pizza(*toppings):
    print(f"Okay, so I got {*toppings} is that right?")

make_a_pizza(cheese, sausage, peporonni, mushrooms)

When defining functions its possible that you may not know how many parameters to anticipate.To
make this easier Python allows the *args or *(whatevername you want here). *args allows as many
positional arguments as you want. What happens behind the scenes is Python will take those
arguments supplied
to it when the function is called and assign them to a tuple which is an uneditable list.

**kw does the same thing except for key words and packs them into a dict.
----------------------------------------------------------------------------------------------------
What happens when you import a module, even one that is in the same directory?
Well python will take ALL of the functions and copy them to the current file that is being ran the
moment the import is found within the code (that is why you keep the imports at the top. Then those
functions are used like normal if you imported the functions directly or with modulename.funcname
if you imported the entire module.

That is why specifying the right functions you want like this:
from os import system, something_else, something_else_else
Is a best practice.

You can even change the function name OR module name with as new_name like so.
from os import system as this_is_mine_now.

Of course you can also import all functions from a module with *
from os import *.
----------------------------------------------------------------------------------------------------
Import * is considered a mal practice as it will import all functions without specifying what the
function's being imported are called. This can cause developers to import a function whose name has
already been createdi in the code which would cause irregularities and logical errors.
----------------------------------------------------------------------------------------------------
BEST PRACTICES PEP 8
Classes should begin with a captial letter and each word should be capitalized:
MyClass(Object)

Functions should be lower case and words seperated by _'s.

All import statements should be located at the beginning of a file.

Keep all lines of code in Python to a 79 character limit. Should a function's set of paramerters
cause a function to go over the 79 cahracter limit, you should write the first parenthesis and
then on a new line press tab twice and then list all of the parameters, continueing this pattern
until the end of the function definition.
----------------------------------------------------------------------------------------------------
<<<<<<< HEAD
The python key word with is used with another key word as to assign something to a variable. Like so:
filename = "full/path/to/filename"
with open(filename) as file_object_variable:
    for line in file_object_variable:
        print(line)
file_object_variable.close()

You will notice though that the with is some sort of THING in python as it ends with a colon. and
similar to functions its block needs to be tabbed in.

Its good to note that the varibale in that is assigned when declaring the with statement is only
available inside the with block. If you need the value of the variable returned just return it or
assign the value of that variable to a new tag
=======
Why is super called super? its from other coding classes OOP lingo, super is short for super class
and the child class are often called sublcasses in other languages.
----------------------------------------------------------------------------------------------------
QUESTION - Does every child of a parent class inherit all of the functions of the parent? Maybe...
What about __init__?
----------------------------------------------------------------------------------------------------
A confusing way to word or peak of composition is to call it "Instances as Attributes". While it is
correct I find it weird to say!
----------------------------------------------------------------------------------------------------


